<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Transformations of the effective lagrangian &#8212; efttools  documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="transformations-of-the-effective-lagrangian">
<h1>Transformations of the effective lagrangian<a class="headerlink" href="#transformations-of-the-effective-lagrangian" title="Permalink to this headline">Â¶</a></h1>
<p>An effective lagrangian obtained from integration of heavy fields
usually contains operators that aren&#8217;t independent. Several
transformations can be applied to them to write the lagrangian
in terms of a set of operators (a basis) that spans the space
of effective operators.</p>
<p>These transformations are such as Fierz identities or substitutions
of the equations of motion of the light particles. All of them consist
of the subsitution of operators or parts of them by sums of other
operators. The operations described in this section applied to
effective lagrangians or to any other kind of operators sum.</p>
<p>The first step to simplify an effective lagrangian is to collect and
multiply numeric coefficients and constant tensors that appear several
times inside the same operator. To do this, use:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">simplified_lag_1</span> <span class="o">=</span> <span class="n">collect_numbers_and_symbols</span><span class="p">(</span><span class="n">effective_lagrangian</span><span class="p">)</span>
</pre></div>
</div>
<p>Then we can define a set of rules as a list of pairs
<code class="docutils literal"><span class="pre">(pattern,</span> <span class="pre">replacement)</span></code> where <code class="docutils literal"><span class="pre">pattern</span></code> is an operator
and <code class="docutils literal"><span class="pre">replacement</span></code> is an operator sum:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">rules</span> <span class="o">=</span> <span class="p">[(</span><span class="n">Op</span><span class="p">(</span><span class="o">...</span><span class="p">),</span> <span class="n">OpSum</span><span class="p">(</span><span class="o">...</span><span class="p">)),</span> <span class="p">(</span><span class="n">Op</span><span class="p">(</span><span class="o">...</span><span class="p">),</span> <span class="n">OpSum</span><span class="p">(</span><span class="o">...</span><span class="p">)),</span> <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">pattern</span></code> may contain tensors with negative indices corresponding
to indices that are not contracted inside <code class="docutils literal"><span class="pre">pattern</span></code>. In that
cases, the operators in replacement should also contain the same
negative indices. When <code class="docutils literal"><span class="pre">pattern</span></code> is substituted inside an operator
<code class="docutils literal"><span class="pre">op</span></code>, the indices in <code class="docutils literal"><span class="pre">op</span></code> outside <code class="docutils literal"><span class="pre">pattern</span></code> that are contracted
with indices inside pattern appear as contracted with the
corresponding ones in the operators of <code class="docutils literal"><span class="pre">replacement</span></code>. For example,
to replace <span class="math">\(t_{ij}r_{ik}\)</span> by <span class="math">\(-s_{mnk}u_{nmj}\)</span> we would
write the rule:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">Op</span><span class="p">(</span><span class="n">t</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">r</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)),</span> <span class="n">OpSum</span><span class="p">(</span><span class="o">-</span><span class="n">Op</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">u</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))))</span>
</pre></div>
</div>
<p>The operators of the basis should be represented by tensor with a name
identifing the operator. They can be defined using
<a class="reference internal" href="moddoc.html#efttools.operators.tensor_op" title="efttools.operators.tensor_op"><code class="xref py py-func docutils literal"><span class="pre">efttools.operators.tensor_op()</span></code></a> when they don&#8217;t have
free indices and <a class="reference internal" href="moddoc.html#efttools.operators.flavor_tensor_op" title="efttools.operators.flavor_tensor_op"><code class="xref py py-func docutils literal"><span class="pre">efttools.operators.flavor_tensor_op()</span></code></a>
when they do. So we usually define:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Op1</span> <span class="o">=</span> <span class="n">tensor_op</span><span class="p">(</span><span class="s2">&quot;Op1&quot;</span><span class="p">)</span>
<span class="n">Op2</span> <span class="o">=</span> <span class="n">tensor_op</span><span class="p">(</span><span class="s2">&quot;Op2&quot;</span><span class="p">)</span>
<span class="o">...</span>

<span class="n">Opf1</span> <span class="o">=</span> <span class="n">flavor_tensor_op</span><span class="p">(</span><span class="s2">&quot;Opf1&quot;</span><span class="p">)</span>
<span class="n">Opf2</span> <span class="o">=</span> <span class="n">flavor_tensor_op</span><span class="p">(</span><span class="s2">&quot;Opf1&quot;</span><span class="p">)</span>
<span class="o">...</span>
</pre></div>
</div>
<p>and then specify how to identify them using rules:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">op_def_rules</span> <span class="o">=</span> <span class="p">[(</span><span class="n">Op</span><span class="p">(</span><span class="o">...</span><span class="p">),</span> <span class="n">OpSum</span><span class="p">(</span><span class="n">Op1</span><span class="p">)),</span>
                <span class="p">(</span><span class="n">Op</span><span class="p">(</span><span class="o">...</span><span class="p">),</span> <span class="n">OpSum</span><span class="p">(</span><span class="n">Op2</span><span class="p">)),</span>
                <span class="o">...</span>
                <span class="p">(</span><span class="n">Op</span><span class="p">(</span><span class="o">...</span><span class="p">),</span> <span class="n">OpSum</span><span class="p">(</span><span class="n">Opf1</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="o">...</span><span class="p">))),</span>
                <span class="p">(</span><span class="n">Op</span><span class="p">(</span><span class="o">...</span><span class="p">),</span> <span class="n">OpSum</span><span class="p">(</span><span class="n">Opf2</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="o">...</span><span class="p">)))</span>
                <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>Then we are ready to apply the rules using <a class="reference internal" href="moddoc.html#efttools.transformations.apply_rules_until" title="efttools.transformations.apply_rules_until"><code class="xref py py-func docutils literal"><span class="pre">apply_rules_until()</span></code></a>
to get to the basis:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">basis_op_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Op1&quot;</span><span class="p">,</span> <span class="s2">&quot;Op2&quot;</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="s2">&quot;Opf1&quot;</span><span class="p">,</span> <span class="s2">&quot;Opf2&quot;</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
<span class="n">simplified_lag_2</span> <span class="o">=</span> <span class="n">apply_rules_until</span><span class="p">(</span>
    <span class="n">simplified_lag_1</span><span class="p">,</span> <span class="n">rules</span> <span class="o">+</span> <span class="n">op_def_rules</span><span class="p">,</span> <span class="n">basis_op_names</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">max_iter</span></code> is the maximum number of applications of rules to each
operator.</p>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/transformations.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Juan Carlos Criado Alamo.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="_sources/transformations.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>